import base64
import json
import mimetypes
import os
import time
from typing import Tuple

import requests

DEFAULT_MODEL_URL = (
    "https://generativelanguage.googleapis.com/v1beta/models/"
    "gemini-2.5-flash-image-preview:generateContent"
)


class GeminiServiceError(RuntimeError):
    """Raised when the Gemini service returns an error response."""


def _fetch_with_backoff(url: str, headers: dict, payload: dict, retries: int = 5, delay: float = 1.0) -> dict:
    """
    Call the Gemini API with exponential backoff to survive transient errors.
    """
    backoff = delay
    for attempt in range(retries):
        try:
            response = requests.post(url, headers=headers, data=json.dumps(payload), timeout=60)
            if response.status_code == 200:
                return response.json()

            if response.status_code == 429 or response.status_code >= 500:
                if attempt == retries - 1:
                    break
                time.sleep(backoff)
                backoff *= 2
                continue

            raise GeminiServiceError(
                f"Gemini API error (status {response.status_code}): {response.text}"
            )
        except requests.exceptions.RequestException as exc:
            if attempt == retries - 1:
                raise GeminiServiceError(f"Failed to reach Gemini API: {exc}") from exc
            time.sleep(backoff)
            backoff *= 2

    raise GeminiServiceError("Exceeded retry budget when calling Gemini API.")


def _encode_image(image_path: str) -> Tuple[str, str]:
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image file not found: {image_path}")

    mime_type, _ = mimetypes.guess_type(image_path)
    if not mime_type or not mime_type.startswith("image/"):
        raise ValueError(f"Unsupported image MIME type for: {image_path}")

    with open(image_path, "rb") as image_file:
        encoded = base64.b64encode(image_file.read()).decode("utf-8")

    return encoded, mime_type


def generate_image_edit(api_key: str, prompt: str, image_path: str) -> bytes:
    """
    Submit the provided image and prompt to Gemini and return the generated bytes.
    """
    if not api_key:
        raise ValueError("API key is required.")
    if not prompt:
        raise ValueError("Prompt is required.")

    base64_image, mime_type = _encode_image(image_path)
    url = f"{DEFAULT_MODEL_URL}?key={api_key}"
    headers = {"Content-Type": "application/json"}
    payload = {
        "contents": [
            {
                "parts": [
                    {"text": prompt},
                    {"inlineData": {"mimeType": mime_type, "data": base64_image}},
                ]
            }
        ],
        "generationConfig": {"responseModalities": ["IMAGE"]},
    }

    response = _fetch_with_backoff(url, headers, payload)

    base64_data = (
        response.get("candidates", [{}])[0]
        .get("content", {})
        .get("parts", [{}])[0]
        .get("inlineData", {})
        .get("data")
    )

    if not base64_data:
        raise GeminiServiceError(f"Gemini response missing image data: {json.dumps(response, indent=2)}")

    return base64.b64decode(base64_data)

